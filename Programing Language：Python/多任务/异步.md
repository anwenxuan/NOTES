# 一、协程

**Coroutine**。即协同运行的例程，它是比是线程（thread）更细量级的用户态线程，特点是允许用户的主动调用和主动退出，挂起当前的例程然后返回值或去执行其他任务，接着返回原来停下的点继续执行。

实现协程可以通过：

> greenlet	早期模块
>
> yield		  关键字
>
> asyncio	 装饰器 3.4
>
> asynic、await 关键字 Python3.5

## 1、greenlet 实现协程

> 官方手册：
>
> ​	english：https://greenlet.readthedocs.io/en/latest/ 
>
> gevent：http://www.gevent.org/contents.html
>
> https://www.osgeo.cn/gevent/intro.html

## 2、yield 实现协程

## 3、asyncio

遇到IO阻塞自动切换

```python
import asyncio

@asyncio.coroutine
def func1():
	print(1)
	# 网络I0请求：下载一张图片
	yield from asyncio.sleep(2） #遇到工0耗时操作，自动化切换到tasks中的其他任务
	print(2)
                             
@asyncio.coroutine
def func20:
print(3)
	# 网络Io请求：下载一张图片
	yield from asyncio.sleep(2） #遇到IO耗时操作，自动化切换到tasks中的其他任务
	print(4)

                             
tasks = [
    asyncio.ensure_future( func10 ),
    asyncio.ensure future( func20 )
]

                             
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
```

## 4、async & await 

python3.5之后

```python
import asyncio

async def func1():
	print(1)
	# 网络Io请求：下载一张图片
	await asyncio .sleep(2)#遇到工0耗时操作，自动化切换到tasks中的其他任务
	print(2)
    
async def func2():
	print(3)
	# 网络Io请求：下载一张图片
	await asyncio .sleep(2） # 遇到I0耗时操作，自动化切换到tasks中的其他任务
	print(4)

tasks = [
    asyncio.ensure_future( func1() ),
    asyncio.ensure_future( func2() )
]
loop = asyncio.get_event_loop(
loop.run_until_complete(asyncio.wait(tasks))
```



# 二、异步

异步是指在处理调用这个事务的之后，不会等待这个事务的处理结果，直接处理第二个事务去了，通过状态、通知、回调来通知调用者处理结果。

## 1、事件循环

```python 
# 伪代码
任务列表 =〔任务1，任务2，任务3，...〕

while True:
	可执行的任务列表，已完成的任务列表 二去任务列表中检查所有的任务，将，可执行’和，已完成，的任务返回
	for 就绪任务 in 可执行的任务列表：
		执行已就绪的任务
	for 已完成的任务 in 已完成的任务列表：
		在任务列表中移除 已完成的任务
	如果 任务列表 中的任务都已完成，则终止循环

import asyncio
# 去生成或获取一个事件循环
1oop = asyncio.get_event_1oop0
# 将任务放到、任务列表
1oop.run_until_complete（任务）
```

## 2、使用

协程函数，定义函数时候 async def 函数名

协程对象，执行 协程函数( 得到的协程对象。

```python
async def funcO:
pass
result = funcO
注意：执行协程西数创建协程对象，西数内部代码不会执行。
如果想要运行协程函数内部代码，必须要讲协程对象交给事件循环来处理。
import asyncio
async def funcO): f
print("H*‡S! ")
result = funcO)
# loop = asyncio.get_event_loop0
# loop.run_until_complete( result )
asyncio.run( result ) # python3.7
```



